---
layout: post
title: ECMAScript 继承
categories: 原创
tags: javascript
---

想着想着困了也就睡了，平凡的不平凡的还是过了

<!--more-->

我是非常不喜欢用继承的，所以对此的概念也不强，或者说自己抽象的能力不强。希望自己对此不仅有些了解，而是自己能真正的用好这个东西。

继承方式分文两种：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。`ECMAScript`只支持实现继承，并且`ECMAScript`没有类继承模型，所有实现继承的方式主要通过原型链。

### 原型链

既然说`ECMAScript`实现继承的方式是基于原型链的，所以我们先看一下什么是原型链，每个构造函数都有一个原型对象，原型对象都包括一个指向构造函数的指针，而实例都包含一个指向原型对象内部的指针。如果这个时候我们将这个实例赋值给另一个原型对象，这个时候新的原型对象将包含一个指向之前那个原型对象内部的指针，且根据链式的关系，新的原型对象也就包含一个指向构造函数的指针，相应的，构造函数又有一个原型对象。这样就构成了实例与原型的链条，这个就是原型链(我是这样理解的)。下面看个代码例子：

    function Father(){
        this.property = true;
    }
    Father.prototype.getSuperValue = function(){
        return this.property;
    }
    function Son(){
        this.subproperty = false;
    }
    Son.prototype = new Father();
    Son.prototype.getSubValue = function(){
        return this.subproperty;
    }
    var instance = new Son();
    console.log(instance.getSuperValue())

以上就是一个继承的简单实现。定义了一个构造函数`Father`，`Father`有个原型对象，原型对象上有一个方法`getSuperValue`，又定义了一个构造函数`Son`，将`Father`的实例赋值给`Son`的原型对象，再给`Son`的原型对象上添加一个方法`getSubValue`，在把`Son`的实例赋值给`instance`，这时`instance`就有`Son`的`subproperty`的属性和`getSubValue`方法，及`Father`的`property`的属性和`getSuperValue`方法。这样就完成了一个继承。

但是这个这些方法都分别在哪里呢？`instance`的`subproperty`属性是直接挂在`instance`上，`instance`的`getSubValue`方法和`property`属性是挂在`__proto__`上的，`instance`的`getSuperValue`方法是挂在`instance`的`__proto__`的`__proto__`上的。这个也可以体现原型链。

上面这中挂载结构也可以体现搜索过程。首先会搜索实例上，然后会搜索`Son.prototype`，最后会搜索`Father.prototype`。这样的寻找方式，来找到对应的方法。

问题：这样的继承方式会带来一个问题，`instance.constructor`变成了`Father`；
