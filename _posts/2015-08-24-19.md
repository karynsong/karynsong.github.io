---
layout: post
title: node 基础学习
categories: 原创
tags: node
---

夏天的时光要溜走，荣我在你心里住上一段时间

<!--more-->

瞎鸡巴忙了一个多月之后，对`node`终于有一点点认识了，我对于一个新东西的学习一向主张先搞个东西出来。这个过程中我很可能完全不懂，什么都乱用，但是这个过程之后，再次进行系统的学习的时候，有很多东西，你就可以结合当时自己做的实例来分析。当然仅供个人扯淡。

如果对`javascript`有深入的了解，那`node`简直是分分钟入门。所以最好在学习`node`之前温补一下`javascript`的基础知识，又把`javascript 高级程序设计`看了一遍，尽管一半时间都在打呼呼，但是还是算翻了一遍吧，至少对其中的一些大概了解了一下。真希望那本书能越翻越薄，越读越快。前期还做了一些笔记，后来觉得很多知识需要融会贯通才行，看那上面的知识完全不够。扯这些，就是想在学习`node`之前能把基础学习扎实了。

### 阻塞与非阻塞IO

`node`是非阻塞单线程的。阻塞就是说程序可以睡觉，什么事儿都不做。`node`采用的是事件轮询机制，这个机制是个啥？就是我先说我中午要出去吃饭，然后我就不断问时间，几点了，几点了，到了中午，好这个时候，时间抛出事件中午了，然后我就接到这么个时间，中午了，然后我就执行去吃饭。这种机制是非阻塞的。阻塞就是，什么都没干，然后到了中午，好的吃饭。

单线程，这是一个怎么也无法改变的事实，单线程是指啥，我说了我中午要去吃饭。但是中午前5分钟，我说我要改个`bug`，事件在中午前五分钟抛出事件，我开始改`bug`,结果我发现我能力太差了，改`bug`五分钟的之后，时间通知我了吗？没有，他说我等你改完再告诉你吃饭，改了半个小时了，搞定了，然后立马通知我，吃饭了。但是这个时候时间已经到了`12：25`了，然后我去吃饭了。

单线程既然这么傻，那怎么做到高并发呢？想什么呢。都说了单线程，如果不引入更多的并行执行线程，并发量就是1，能处理的过来，完全是靠`V8引擎和非阻塞IO配合的好`，每次V8调用一个函数时，V8就会将其添加到调用堆栈上，V8执行`javascript`非常快。

多进程，单线程`node`可以`fork`出多个子进程，监听子进程处理程序，然后返回给主进程。

### 模块系统

模块化对于前端肯定不陌生，为了避免过多使用全局变量，也为了能更好的组织自己的代码，将一个文件拆成多个模块，进行开发，由此有两个模块化模式产生，`AMD和CMD`。

引入模块时又分为相对模块与绝对模块。`node`的模块化引入了`requireJs`的`AMD`类型模块化。你可以将其他模块预先加载进来，然后直接对其中的`API`进行使用，如果是`node_modules`中的模块或者是系统模块，可以直用`require`不加任何后缀和路径进行引用称之为绝对模块，如：引入文件系统`var fs = require('fs')`；自己写了一个文件要引入依赖的话需要加上相对的路径。如：引入一个同级目录的`module.js`文件`var module = require('./module.js')`；

暴露：`module.js`需要暴露出一些方法供引入者使用的话，直接写`exports.name = 'karyn'`；外界引入时`var module = require('./module.js')`，`module.name === 'karyn'了，`exports`就是暴露的一个对象，可以将暴露的方法挂载到该对象上，外界引用的时候可以获取到。

### 事件

事件的机制贯穿整个`nodeJs`，事件是`Node`非阻塞设计的重要体现。`Node`通常不会直接返回数据，而是采用分发事件来传递数据的方式。非阻塞的体现在于，我监听了一个事件之后我就不管了，知道有事件通知我，然后我再做回馈。分发事件也是一样的，分发了事件之后我也不管了，所以两者之间也不会是谁等谁，事件的这种机制就决定了非阻塞。使用方式如下：

    var EventEmitter = require('events').EventEmitter,
        thisEvents = new EventEmitter();

    thisEvents.on('hello', function(){
        console.log('hello')
    });

    thisEvents.emit('hello')

前面写过一个对于[`javascript`事件](http://localhost:4000/2015-07/15/)的理解，事件的基本运行机制和怎样实现一个自定义事件。我妄自揣测`node`的事件实现应该和自定义事件差不多，但是肯定是要难很多的。

### `buffer`

对此处的概念理解不是非常深，所以不敢妄下任何结论（当然也不是说我写的那些就是因为我有非常深入的了解，我写下来顶多是为了让我自己理解的更透彻，或者自己在记录这个的过程中又会有新的发现而已）。之后会去完善。
