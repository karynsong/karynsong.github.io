---
layout: post
title: node 的内存控制
categories: 原创
tags: node
---

清风徐来，水波不兴；谈笑风生那可遇不可求的事情

<!--more-->

谈笑风生那可遇不可求的事情可以说是温文尔雅的形容了吹牛逼一说。其实和我写这篇博客差不多。标题前端看起来高大上，后端看起来就太土了。

说到内存控制，当然就有垃圾回收机制，前端开发者基本上不需要对内存进行控制，如果要说真正有点控制的话，就是内存泄露的造成，当`DOM`绑定了太多事件没有及时解绑，但是`DOM`被销毁了，长此以往不刷新浏览器，内存也就泄露了。私自揣测那`node`也会存在类似问题，但是服务器要求的肯定是高效。所以需要内存管理和垃圾回收，`V8`引擎懂你所有。

### 前端的内存管理

说到这里就再来回顾一下前端里的内存管理吧。

#### 垃圾标记

标记清除：我们浏览器一般常用标记的方式是标记清除，当变量进入环境时，我们就对其进行标记。当其离开环境时，我们对其标记为离开环境。垃圾收集器会把所有内存中的变量都加上变量，去掉那些已经标记和被标记的变量所引用的变量。被标记的内存会被回收。(有点绕口，其实就是标记还在用的，去掉没有用的)

引用计数：如果变量被声明，并赋值后，计数为1，当这个变量被被人引用加1，当引用量减少时减1，当这个值引用次数变成0时，就对其进行回收。

#### 内存泄露

上面将了两种垃圾回收机制，第一个是使用的比较普遍的。但是第二种的就会造成内存泄露。`IE9`以下的`DOM`和`BOM`不是真正的`javascript`对象，所以使用的回收机制是第二种，当我们在绑定事件时，如果不手动解绑事件，如果认为删掉了对象就万事大吉的话就会造成内存泄露，因为现在虽然表象上是删除了`DOM`对象，但对其还有引用，所以`DOM`还是没有被垃圾回收。

另一种内存泄露的例子是：

    var element = document.getElementById('karyn'),
        myObject = new Object();
    myObject.element = element;
    element.xxx = myObject;

上面的例子是一个循环引用，由于引用一直存在，所以`DOM`就算删掉也不会被回收

#### 优化性能

在`javascript`中本身是不允许强制进行垃圾回收的，两个浏览器提供手动触发垃圾回收机制：

    // IE提供
    window.CollectGarbage()
    // opera提供
    window.opera.collect()

管理好内存：只保存必要的数据，一旦数据不再使用就解除引用将值置为`null`，等待回收。

### `node`的内存机制


